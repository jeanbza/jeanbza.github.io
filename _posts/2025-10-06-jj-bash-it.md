---
layout: post
title:  "A jj plugin for bash-it"
date:   2025-10-06 02:55:23 -0600
categories: 
toc: true
---

I've been using [`jj`](https://github.com/jj-vcs/jj) instead of `git`, and it's
been great. One thing I really miss using `git`, though, is a nice terminal
prompt that I get from [`bash-it`](https://github.com/Bash-it/bash-it). So, I
whipped up one for `jj`.

![jj prompt](/assets/jj.png)

*Notice:* The prompt now prints |jj:**ty**mnqrpn - readme| and
|jj:**s**ttyyssy|. The coloured short letters (ty, s) are the `jj` short prefix,
the full 8 characters are the short rev, and the optional `- readme` show the
bookmark associated with the rev if one exists.

I thought I'd post it here if anyone else is looking for this:

1. Create `~/.bash_it/custom/jj.plugins.bash` with:

    ```sh
    # Set jj prompt to be enabled by default
    SCM_PROMPT_SHOW_JJ_PRIVATE_INFO="${SCM_PROMPT_SHOW_JJ_PRIVATE_INFO:-true}"

    # jj repo check
    function is_jj_repo {
    if [ -d ".jj" ]; then
        return 0
    else
        return 1
    fi
    }

    # jj prompt
    function jj_prompt_info {
    if [ "$SCM_PROMPT_SHOW_JJ_PRIVATE_INFO" = "true" ] && is_jj_repo; then
        local jj_info
        local short_hash
        local jj_bookmarks

        # Get an 8-character short hash and bookmarks
        short_hash=$(jj log -r @ --no-graph --template 'change_id.short(8)' 2>/dev/null)
        jj_bookmarks=$(jj log -r @ --no-graph --template 'bookmarks.map(|b| b.name())' 2>/dev/null)

        # Exit if we couldn't get a hash
        if [[ -z "$short_hash" ]]; then
        return
        fi

        # --- DYNAMIC HIGHLIGHTING ---
        # Get the shortest unique prefix using the template you found
        local prefix=$(jj log -r @ --no-graph --template 'self.change_id().shortest()' 2>/dev/null)

        # Fallback: if the command fails, default to the first character. Maybe
        # unnecessary.
        if [[ -z "$prefix" ]]; then
        prefix="${short_hash:0:1}"
        fi

        # Determine the rest of the hash by removing the prefix
        local rest_of_hash="${short_hash#$prefix}"
        local colored_hash="$MAGENTA$prefix$WHITE$rest_of_hash"

        # Build the base info string: always start with the hash
        jj_info="$colored_hash"

        # If bookmarks exist, append them
        if [[ -n "$jj_bookmarks" ]]; then
        jj_info="$jj_info - $jj_bookmarks"
        fi

        # Wrap in parentheses
        jj_info="($jj_info)"

        # --- ASTERISK LOGIC ---
        local first_bookmark="${jj_bookmarks%% *}"
        if [[ -n "$first_bookmark" ]]; then
        local any_diff
        any_diff=$(jj diff --summary --from "${first_bookmark}@origin" 2>/dev/null)
        if [[ -n "$any_diff" ]]; then
            jj_info="$jj_info*"
        fi
        fi

        echo -e "${SCM_THEME_PROMPT_PREFIX}jj:${jj_info}${SCM_THEME_PROMPT_SUFFIX}"
    fi
    }
    ```

2. Update `~/.bash_it/themes/<theme>/<theme>.bash` (ex
`~/.bash_it/themes/sexy/sexy.bash`) to include your prompt next to the `git`
prompt:

```sh
function prompt_command() {
  # Old
  # PS1="\[${BOLD}${MAGENTA}\]\u \[$WHITE\]at \[$ORANGE\]\h \[$WHITE\]in \[$GREEN\]\w\[$WHITE\]\$([[ -n \$(git branch 2> /dev/null) ]] && echo \" on \")\[$PURPLE\]\$(parse_git_branch)\[$WHITE\]\n\$ \[$RESET\]"

  # New
  PS1="\[${BOLD}${MAGENTA}\]\u \[$WHITE\]at \[$ORANGE\]\h \[$WHITE\]in \[$GREEN\]\w\[$WHITE\]\$([[ -n \$(git branch 2> /dev/null) ]] && echo \" on \")\[$PURPLE\]\$(parse_git_branch)\[$CYAN\]$(jj_prompt_info)\[$WHITE\]\n\$ \[$RESET\]"
```

And then you get some nice `jj` prompts!